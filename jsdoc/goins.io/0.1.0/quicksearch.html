<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_http.js.html":{"id":"lib_http.js.html","title":"Source: lib/http.js","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Source: lib/http.js import { STATUS_CODES } from 'http'; import _ from 'underscore'; import { networkInterfaces } from 'os'; const ifaces = networkInterfaces(); /** * @param {string} requiredIface * @return {string} */ exports.getLocalIP = requiredIface =&gt; { if (typeof requiredIface !== 'string') throw TypeError('utils/ip.js: required interface must be a string'); if (!_.has(ifaces, requiredIface)) throw Error(`utils/ip.js: no such interface '${requiredIface}'. ` + `Available interfaces are: ${_(ifaces).keys().join(', ')}`); return _.chain(ifaces) .pairs() .filter(([iface, details]) =&gt; requiredIface === iface) .map(([iface, details]) =&gt; details) .map(details =&gt; _(details).filter(detail =&gt; detail.family === 'IPv4')) .map(details =&gt; _(details).map(detail =&gt; detail.address)) .map(details =&gt; _(details).last()) .last() .value(); }; /** * @type {Object.&lt;string, string&gt;} */ exports.statusDescriptions = STATUS_CODES; /** * @type {Object.&lt;string, number&gt;} */ exports.statusCodes = _.chain(STATUS_CODES) .pairs() .map(([codeStr, description]) =&gt; [parseInt(codeStr), description]) .map(([code, description]) =&gt; [ description.replace(/'m/g, ' am') .replace(/'s/g, ' is') .replace(/'re/g, ' are') .replace(/[- ]/g, '_') .toUpperCase(), code]) .object() .value(); × Search results Close "},"models_users.js.html":{"id":"models_users.js.html","title":"Source: models/users.js","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Source: models/users.js import cson from 'cson'; import path from 'path'; import fs from 'fs'; import _ from 'underscore'; import { throwWithMessage } from '../lib/exceptions'; import schema from '../lib/object-schema'; var users = {}; var maxID = 0; const dataFilePath = path.join('data', 'users.cson'); exports.loadUsers = () =&gt; { users = cson.load(dataFilePath); maxID = parseInt(_.max(_.keys(users))); }; const saveUsers = exports.saveUsers = () =&gt; fs.writeFileSync(dataFilePath, cson.createCSONString(users, { indent: 4 })); exports.getUserData = () =&gt; users; /** * @param {ServerRequest} req * @return {bool} */ exports.hasUserCookie = (req) =&gt; req.cookies.user !== undefined &amp;&amp; req.cookies.user !== ''; exports.addUser = (user) =&gt; { schema.validate(user, { 'name': schema.required(schema.NotEmptyString), 'surname': schema.required(schema.NotEmptyString), 'email': schema.required(schema.Email), 'password': schema.required(schema.NotEmptyString), 'group': schema.required(schema.IntegerString), 'type': schema.required(schema.Enum('student', 'teacher')), 'lesson': schema.conditional(user.type === 'teacher', 'User isn\\'t a teacher', schema.Enum( 'softskills', 'hardskills')) }); if (userExists(_.pick(user, 'name', 'surname'))) { throwWithMessage( `There's already ${user.type} in GoITeens with name '${user.name}' and surname '${user.surname}'`); } else { users[computeUserID(user)] = user.type === 'student' ? _.defaults(user, { goins: 0, purchases: [], purchasesLog: [], rewardsLog: [], punishmentsLog: [] }) : _.defaults(user, { rewardsLog: [], punishmentsLog: [] }); saveUsers(); } }; const userExists = exports.userExists = (requiredProperties) =&gt; _.any(users, user =&gt; _.isMatch(user, requiredProperties)); exports.selectUsers = (requiredProperties) =&gt; _.filter(users, user =&gt; _.isMatch(user, requiredProperties)); const computeUserID = exports.computeUserID = (user) =&gt; { maxID++; return maxID; }; × Search results Close "},"lib_templates.js.html":{"id":"lib_templates.js.html","title":"Source: lib/templates.js","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Source: lib/templates.js import htmlMinifier from 'html-minifier'; import uglifyJS from 'uglify-js'; import CleanCSS from 'clean-css'; import nunjucks from 'nunjucks'; const CLEAN_CSS_CONFIGURATION = new CleanCSS({ }); const UGLIFY_JS_OPTIONS = { }; function minifyCSS(css) { return new CleanCSS({ }).mminify(css).styles; } /** * @param {string} html * @return {string} */ function minifyHTML(html) { return htmlMinifier.miminify(html, { collapseBooleanAttributes: true, collapseInlineTagWhitespace: true, collapseWhitespace: true, conservativeCollapse: true, maxLineLength: 120, minifyCSS, minifyJS: UGLIFY_JS_OPTIONS, removeAttributeQuotes: true, removeComments: true, removeEmptyAttributes: true, removeRedundantAttributes: true }); } /** * @param {string} file * @param {Object.&lt;string, ?&gt;} data */ function renderNunjucks(file, data) { return minifyHTML(nunjucks.render(file, data), { collapseBooleanAttributes: true, collapseInlineTagWhitespace: true, collapseWhitespace: true, conservativeCollapse: true, maxLineLength: 120, minifyCSS: true, minifyJS: true, minifyURLs: { ignore_www: true }, removeAttributeQuotes: true, removeComments: true, removeEmptyAttributes: true, removeRedundantAttributes: true }); } module.exports = { minifyHTML, renderNunjucks }; × Search results Close "},"lib_objects-chema.js.html":{"id":"lib_objects-chema.js.html","title":"Source: lib/objects-chema.js","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Source: lib/objects-chema.js import _ from 'underscore'; import { inspect } from 'util'; /** * @tutorial lib/object-schema * @module lib/object-schema */ export class ValidationError { constructor(path, value, message) { this.path = path; this.value = value; this.message = message; } toString() { return `${this.path.join('/')}: ${inspect(this.value)}: ${this.message}`; } } /** * @callback TypePredicate * Callback for type predicates. Type predicate is a function, that checks property and * returns array of errors. * @param {Object} object object * @param {string} prop property name * @return {ValidationError[]} array of errors (empty array indicates that property is valid) * @see checkValue * @see ValuePredicate */ /** * @callback ValuePredicate * Callback for value predicates. Value predicate works like {@link TypePredicate}, but * accepts value and property name. * @param {Object} object object * @param {string} prop property name * @return {ValidationError[]} array of errors (empty array indicates that property is valid) * @see checkValue * @see TypePredicate */ /** * Combine type predicates with logical **AND** operation. * @param {...TypePredicate} predicates * @return {TypePredicate} * @see TypePredicate */ export function and(...predicates) { return (object, prop) =&gt; _.foldl(predicates, (errors, predicate) =&gt; _.isEmpty(errors) ? predicate(object, prop) : errors, []); } /** * Returns type predicate, that: * 1. If property is `undefined`/`null` - returns error. * 2. otherwise - calls predicate. * @param {TypePredicate} predicate * @return {TypePredicate} * @see TypePredicate * @see optional * @see conditional */ export function required(predicate) { return (object, prop) =&gt; _.has(object, prop) &amp;&amp; object[prop] !== null ? // if predicate(object, prop) : // then object[prop] === null ? // else if [new ValidationError([prop], null, 'is null')] : // then [new ValidationError([prop], undefined, 'is undefined')]; // else } /** * Returns type predicate, that: * 1. If property is `undefined`/`null` - returns no errors. * 2. otherwise - calls predicate. * @param {TypePredicate} predicate * @return {TypePredicate} * @see TypePredicate * @see required * @see conditional */ export function optional(predicate) { return (object, prop) =&gt; _.has(object, prop) &amp;&amp; object[prop] !== null ? predicate(object, prop) : []; } /** * Returns type predicate, that: * 1. If property is `undefined`/`null` - return no errors. * 2. if condition is `true` - calls predicate. * 3. if condition is `false` - returns error with error message. * @param {bool} condition * @param {string} errorMessage * @param {TypePredicate} predicate * @return {TypePredicate} * @see TypePredicate * @see required * @see optional */ export function conditional(condition, errorMessage, predicate) { return (object, prop) =&gt; (_.isFunction(condition) &amp;&amp; condition()) || condition ? // if predicate(object, prop) : // then _.has(object, prop) &amp;&amp; object[prop] !== null ? // else if [_.isFunction(errorMessage) ? errorMessage() : errorMessage] : // then []; // else } /** * Transforms value predicate into type predicate. * @param {ValuePredicate} predicate * @return {TypePredicate} * @see TypePredicate * @see ValuePredicate */ export function checkValue(predicate) { return (object, prop) =&gt; predicate(object[prop], prop); } function invalidTypeError(prop, value, expected) { return new ValidationError([prop], value, `has type '${typeof value}', but expected type is ${expected}`); } /** * Type predicate for any type. * @constant * @type {TypePredicate} * @see TypePredicate */ export const Any = (object, prop) =&gt; []; // eslint-disable-line no-unused-vars /** * Type predicate for strings. * @type {TypePredicate} * @see TypePredicate * @see NotEmptyString * @see regexp * @see IntegerString * @see NumberString * @see Email */ export const String = checkValue((value, prop) =&gt; _.isString(value) ? [] : [invalidTypeError(prop, value, 'String')]); /** * Type predicate for not empty strings. * @type {TypePredicate} * @see TypePredicate * @see String */ export const NotEmptyString = and(String, checkValue((value, prop) =&gt; _.isEmpty(value) ? [new ValidationError([prop], value, 'is empty')] : [])); const emailUserPartRegexp = /^([A-Z0-9_%+\\-!#$&amp;'*/=?^`{|}~]+\\.?)*[A-Z0-9_%+\\-!#$&amp;'*/=?^`{|}~]+$/i; const emailDomainPartRegexp = /^([A-Z0-9-]+\\.?)*[A-Z0-9-]+(\\.[A-Z]{2,9})+$/i; /** * Type predicate for strings with email. * @type {TypePredicate} * @see TypePredicate * @see NotEmptyString */ export const Email = and(NotEmptyString, checkValue((value, prop) =&gt; { const tab = value.split('@'); if (tab.length !== 2 || !emailUserPartRegexp.test(tab[0]) || !emailDomainPartRegexp.test(tab[1])) // eslint-disable-line no-magic-numbers return [new ValidationError([prop], value, 'isn\\'t a valid email address')]; else return []; })); const integerRegexp = /^-?(0|[1-9]\\d*)\\.?$/; /** * Type predicate for strings with integer literal. * @type {TypePredicate} * @see TypePredicate * @see NotEmptyString * @see NumberString */ export const IntegerString = and(NotEmptyString, checkValue((value, prop) =&gt; integerRegexp.test(value) ? [] : [new ValidationError([prop], value, 'isn\\'t an integer literal')])); const numberRegexp = /^-?(0|[1-9]\\d*)\\.?\\d*([Ee][+-]?(0|[1-9]\\d*))?$/; /** * Type predicate for strings with integer or float literal. * @type {TypePredicate} * @see TypePredicate * @see NotEmptyString * @see IntegerString */ export const NumberString = and(NotEmptyString, checkValue((value, prop) =&gt; !numberRegexp.test(value) ? [] : [new ValidationError([prop], value, 'isn\\'t a float literal')])); /** * Type predicate for enums. * @param {...*} values * @return {TypePredicate} * @see TypePredicate */ export function Enum(...values) { return checkValue((value, prop) =&gt; _.contains(values, value) ? [] : [new ValidationError([prop], value, `isn't in enum [${values.join(', ')}]`)] ); } /** * Returns type predicate, that checks if string matches regexp. * @param {string|Regexp} _regexp * @return {TypePredicate} * @see TypePredicate * @see String */ export function regexp(_regexp) { return and(String, checkValue((value, prop) =&gt; _regexp.test(value) ? [] : [new ValidationError([prop], value, `doesn't match regexp ${_regexp}`)])); } const alphanumRegexp = /^[a-zA-Z0-9]+$/; /** * Type predicate for strings with only alpha-numeric characters. * @type {TypePredicate} * @see TypePredicate * @see NotEmptyString */ export const AlphanumString = and(NotEmptyString, checkValue((value, prop) =&gt; alphanumRegexp.test(value) ? [] : [new ValidationError([prop], value, 'isn\\'t alpha-numeric')])); /** * Type predicate for numbers. * @type {TypePredicate} * @see TypePredicate */ export const Number = checkValue((value, prop) =&gt; _.isNumber(value) ? [] : invalidTypeError(prop, value, 'Number')); /** * Type predicate for booleans. * @type {TypePredicate} * @see TypePredicate */ export const Boolean = checkValue((value, prop) =&gt; _.isBoolean(value) ? [] : [invalidTypeError(prop, value, 'Boolean')]); /** * Type predicate for objects. * @param {Object.&lt;string, TypePredicate&gt;} schema * @return {TypePredicate} * @see TypePredicate */ export function Object(schema) { return checkValue((value, prop) =&gt; _.isObject(value) ? validate(value, schema).errors : [invalidTypeError(prop, value, 'Object')]); } /** * Type predicate for functions. * @type {TypePredicate} * @see TypePredicate */ export const Function = checkValue((value, prop) =&gt; _.isFunction(value) ? [] : [invalidTypeError(prop, value, 'Function')]); function prepend(value, array) { // Use &quot;slice&quot; to avoid mutating &quot;a&quot;. var newArray = array.slice(0); // eslint-disable-line no-magic-numbers newArray.unshift(value); return newArray; } /** * Type predicate for arrays. * @param {TypePredicate} predicate type predicate for all elements in array. * @return {TypePredicate} * @see TypePredicate * @see NotEmptyArray * @see minLength * @see maxLength */ export function Array(predicate) { return checkValue((value, prop) =&gt; _.isArray(value) ? _.map(_.flatten(_.map(value, (element, index) =&gt; predicate(value, index))), ({ path, value: errorValue, message }) =&gt; new ValidationError(prepend(prop, path), errorValue, message) ) : invalidTypeError(prop, value, 'Array')); } /** * Type predicate for not empty arrays. * @param {TypePredicate} predicate type predicate for all elements in array. * @return {TypePredicate} * @see TypePredicate * @see Array * @see minLength * @see maxLength */ export function NotEmptyArray(predicate) { return and( checkValue((value, prop) =&gt; !_.isArray(value) ? // if invalidTypeError(prop, value, 'Array') : // then _.isEmpty(value) ? // else if [new ValidationError([prop], value, 'is empty')] : // then []), // else Array(predicate)); } /** * Type decorator that adds min value to type predicate. * @param {*} minValue * @param {TypePredicate} predicate * @return {TypePredicate} */ export function min(minValue, predicate) { return and(predicate, checkValue((value, prop) =&gt; value &lt; minValue ? [new ValidationError([prop], value, `is less than min value '${minValue}'`)] : [])); } /** * Type decorator that adds max value to type predicate. * @param {*} maxValue * @param {TypePredicate} predicate * @return {TypePredicate} */ export function max(maxValue, predicate) { return and(predicate, checkValue((value, prop) =&gt; value &gt; maxValue ? [new ValidationError([prop], value, `is greater than max value '${maxValue}'`)] : [] )); } /** * Type decorator that adds max length to type predicate. * @param {*} maxLen * @param {TypePredicate} predicate * @return {TypePredicate} */ export function minLength(minLen, predicate) { return and(predicate, checkValue((value, prop) =&gt; value.length &lt; minLen ? [new ValidationError([prop], value, `length is less than min value '${minLen}'`)] : [])); } /** * Type decorator that adds min length to type predicate. * @param {*} minLen * @param {TypePredicate} predicate * @return {TypePredicate} */ export function maxLength(maxLen, predicate) { return and(predicate, checkValue((value, prop) =&gt; value.length &gt; maxLen ? [new ValidationError([prop], value, `length is greater than max value '${maxLen}'`)] : [])); } /** * Validates object with schema. * @param {Object} object * @param {Object} schema * @return {Object} validation result with 2 properties: `valid` (`bool`) and * `errors` (`TypePredicate[]`) * @see TypePredicate * @tutorial object-schema */ export function validate(object, schema) { var errors = _.flatten(_.map(_.pairs(schema), ([prop, predicate]) =&gt; predicate(object, prop))); return { valid: _.isEmpty(errors), errors }; } × Search results Close "},"lib_path.js.html":{"id":"lib_path.js.html","title":"Source: lib/path.js","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Source: lib/path.js import fs from 'fs'; import path from 'path'; import _ from 'underscore'; /** * @param {string} dir * @return {string[]} */ const readdirRecursiveSync = exports.readdirRecursiveSync = (dir) =&gt; _.flatten(_.map(fs.readdirSync(dir), fileName =&gt; { const fullPath = path.join(dir, fileName); return fs.statSync(fullPath).isDirectory() ? readdirRecursiveSync(fullPath) : [fullPath]; })); × Search results Close "},"lib_exceptions.js.html":{"id":"lib_exceptions.js.html","title":"Source: lib/exceptions.js","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Source: lib/exceptions.js /** * @param {string} message */ exports.throwWithMessage = function (message) { throw new Error(message); }; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Global Members &lt;constant&gt; readdirRecursiveSync Source: lib/path.js, line 9 statusCodes :Object.&lt;string, number&gt; Type: Object.&lt;string, number&gt; Source: lib/http.js, line 37 statusDescriptions :Object.&lt;string, string&gt; Type: Object.&lt;string, string&gt; Source: lib/http.js, line 32 Methods getLocalIP(requiredIface) Parameters: Name Type Description requiredIface string Source: lib/http.js, line 11 Returns: Type string hasUserCookie(req) Parameters: Name Type Description req ServerRequest Source: models/users.js, line 25 Returns: Type bool minifyHTML(html) Parameters: Name Type Description html string Source: lib/templates.js, line 24 Returns: Type string renderNunjucks(file, data) Parameters: Name Type Description file string data Object.&lt;string, ?&gt; Source: lib/templates.js, line 44 throwWithMessage(message) Parameters: Name Type Description message string Source: lib/exceptions.js, line 4 × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Modules × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Tutorials × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage goins.io 0.1.0 × Search results Close "},"module-lib_object-schema.html":{"id":"module-lib_object-schema.html","title":"Module: lib/object-schema","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage Module: lib/object-schema Source: lib/objects-chema.js, line 4 Tutorials: Tutorial: lib/object-schema Members &lt;static, constant&gt; AlphanumString :TypePredicate Type predicate for strings with only alpha-numeric characters. Type: TypePredicate Source: lib/objects-chema.js, line 224 See: TypePredicate NotEmptyString &lt;static, constant&gt; Any :TypePredicate Type predicate for any type. Type: TypePredicate Source: lib/objects-chema.js, line 132 See: TypePredicate &lt;static, constant&gt; Boolean :TypePredicate Type predicate for booleans. Type: TypePredicate Source: lib/objects-chema.js, line 239 See: TypePredicate &lt;static, constant&gt; Email :TypePredicate Type predicate for strings with email. Type: TypePredicate Source: lib/objects-chema.js, line 163 See: TypePredicate NotEmptyString &lt;static, constant&gt; Function :TypePredicate Type predicate for functions. Type: TypePredicate Source: lib/objects-chema.js, line 257 See: TypePredicate &lt;static, constant&gt; IntegerString :TypePredicate Type predicate for strings with integer literal. Type: TypePredicate Source: lib/objects-chema.js, line 179 See: TypePredicate NotEmptyString NumberString &lt;static, constant&gt; NotEmptyString :TypePredicate Type predicate for not empty strings. Type: TypePredicate Source: lib/objects-chema.js, line 152 See: TypePredicate String &lt;static, constant&gt; Number :TypePredicate Type predicate for numbers. Type: TypePredicate Source: lib/objects-chema.js, line 232 See: TypePredicate &lt;static, constant&gt; NumberString :TypePredicate Type predicate for strings with integer or float literal. Type: TypePredicate Source: lib/objects-chema.js, line 190 See: TypePredicate NotEmptyString IntegerString &lt;static, constant&gt; String :TypePredicate Type predicate for strings. Type: TypePredicate Source: lib/objects-chema.js, line 144 See: TypePredicate NotEmptyString regexp IntegerString NumberString Email Methods &lt;static&gt; and(predicates) Combine type predicates with logical AND operation. Parameters: Name Type Argument Description predicates TypePredicate &lt;repeatable&gt; Source: lib/objects-chema.js, line 49 See: TypePredicate Returns: Type TypePredicate &lt;static&gt; Array(predicate) Type predicate for arrays. Parameters: Name Type Description predicate TypePredicate type predicate for all elements in array. Source: lib/objects-chema.js, line 276 See: TypePredicate NotEmptyArray minLength maxLength Returns: Type TypePredicate &lt;static&gt; checkValue(predicate) Transforms value predicate into type predicate. Parameters: Name Type Description predicate ValuePredicate Source: lib/objects-chema.js, line 117 See: TypePredicate ValuePredicate Returns: Type TypePredicate &lt;static&gt; conditional(condition, errorMessage, predicate) Returns type predicate, that: If property is undefined/null - return no errors. if condition is true - calls predicate. if condition is false - returns error with error message. Parameters: Name Type Description condition bool errorMessage string predicate TypePredicate Source: lib/objects-chema.js, line 101 See: TypePredicate required optional Returns: Type TypePredicate &lt;static&gt; Enum(values) Type predicate for enums. Parameters: Name Type Argument Description values * &lt;repeatable&gt; Source: lib/objects-chema.js, line 199 See: TypePredicate Returns: Type TypePredicate &lt;static&gt; max(maxValue, predicate) Type decorator that adds max value to type predicate. Parameters: Name Type Description maxValue * predicate TypePredicate Source: lib/objects-chema.js, line 322 Returns: Type TypePredicate &lt;static&gt; maxLength(minLen, predicate) Type decorator that adds min length to type predicate. Parameters: Name Type Description minLen * predicate TypePredicate Source: lib/objects-chema.js, line 346 Returns: Type TypePredicate &lt;static&gt; min(minValue, predicate) Type decorator that adds min value to type predicate. Parameters: Name Type Description minValue * predicate TypePredicate Source: lib/objects-chema.js, line 311 Returns: Type TypePredicate &lt;static&gt; minLength(maxLen, predicate) Type decorator that adds max length to type predicate. Parameters: Name Type Description maxLen * predicate TypePredicate Source: lib/objects-chema.js, line 334 Returns: Type TypePredicate &lt;static&gt; NotEmptyArray(predicate) Type predicate for not empty arrays. Parameters: Name Type Description predicate TypePredicate type predicate for all elements in array. Source: lib/objects-chema.js, line 294 See: TypePredicate Array minLength maxLength Returns: Type TypePredicate &lt;static&gt; Object(schema) Type predicate for objects. Parameters: Name Type Description schema Object.&lt;string, TypePredicate&gt; Source: lib/objects-chema.js, line 247 See: TypePredicate Returns: Type TypePredicate &lt;static&gt; optional(predicate) Returns type predicate, that: If property is undefined/null - returns no errors. otherwise - calls predicate. Parameters: Name Type Description predicate TypePredicate Source: lib/objects-chema.js, line 83 See: TypePredicate required conditional Returns: Type TypePredicate &lt;static&gt; regexp(_regexp) Returns type predicate, that checks if string matches regexp. Parameters: Name Type Description _regexp string | Regexp Source: lib/objects-chema.js, line 212 See: TypePredicate String Returns: Type TypePredicate &lt;static&gt; required(predicate) Returns type predicate, that: If property is undefined/null - returns error. otherwise - calls predicate. Parameters: Name Type Description predicate TypePredicate Source: lib/objects-chema.js, line 64 See: TypePredicate optional conditional Returns: Type TypePredicate &lt;static&gt; validate(object, schema) Validates object with schema. Parameters: Name Type Description object Object schema Object Source: lib/objects-chema.js, line 361 Tutorials: object-schema See: TypePredicate Returns: validation result with 2 properties: valid (bool) and errors (TypePredicate[]) Type Object Type Definitions TypePredicate(object, prop) Parameters: Name Type Description object Object object prop string property name Source: lib/objects-chema.js, line 21 See: checkValue ValuePredicate Returns: array of errors (empty array indicates that property is valid) Type Array.&lt;ValidationError&gt; ValuePredicate(object, prop) Parameters: Name Type Description object Object object prop string property name Source: lib/objects-chema.js, line 32 See: checkValue TypePredicate Returns: array of errors (empty array indicates that property is valid) Type Array.&lt;ValidationError&gt; × Search results Close "},"tutorial-object-schema.html":{"id":"tutorial-object-schema.html","title":"Tutorial: object-schema","body":" goins.io Modules lib/object-schema Tutorials object-schema Global getLocalIPhasUserCookieminifyHTMLreaddirRecursiveSyncrenderNunjucksstatusCodesstatusDescriptionsthrowWithMessage object-schema lib/object-schema.js TutorialThis module is lightweight object type validator. It's very useful in JSON/REST Web APIs to validate requests with JSON data. Exampleimport schema from 'lib/object-schema'; // Or ./lib/object-schema in project context const userSchema = { users: schema.required(schema.Array( schema.Object({ name: schema.required(schema.minLength(3, schema.maxLength(30, schema.AlphanumString))), password: schema.required(rschema.egexp(/((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{6,20})/)), email: schema.required(schema.Email), status: schema.optional(schema.NotEmptyString), id: schema.required(schema.AlphanumString), friends: schema.optional(schema.Array(schema.AlphanumString)) }) )) } var result = schema.validate(..., userSchema);Function schema.validate is described in documentation. Schema StructureSchema is an object, where keys are property names, and values are type predicates. Type predicate is a function that takes object and property name ((object, prop) =&gt; ...), checks it, and returns array of errors. You can use function checkValue (checkValue((value, prop) =&gt; ...)) to create type predicates easier. List of built-in type predicates Type name Description AlphanumString Alpha-numeric string Any Any type Array(...) Checks each value in array using predicate Boolean Boolean Email Email Enum(a, b, c) Enum Function Function IntegerString String with integer literal NotEmptyArray(...) Like Array(...), but not empty NotEmptyString Like String, but not empty Number Number NumberString String with integer or float literal Object({...}) Takes schema and validates property String String regexp(/abc/) Checks if string matches regexp Also, there're some type decorators. Type decorators are functions, that take type predicate (and, maybe, some arguments) and return new type predicate with new effect. List of built-in type decorators Type decorators Arguments Description and types (rest parameters, not array) If first type check succeeded - check second type, otherwise - return errors. Then continue this operation with 2nd, 3rd, 4th type, and so on. conditional condition (function or boolean), error message (function or string) and type if property isn’t undefined or null and condition is true - check type, otherwise (if property isn’t undefined or null) - throw error. max max value and type If value is greater than max value - throw error, otherwise - check type. maxLength max length and type If length of value is greater than max value - throw error, otherwise - check type. min min value and type If value is less than min value - throw error, otherwise - check type. minLength min length and type If length of value is less than min value - throw error, otherwise - check type. optional type if property is undefined or null - don’t do anything, otherwise - check type. required type if property is undefined or null - return error, otherwise - check type. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
